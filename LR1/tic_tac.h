///\file
///INPUT_ENCODING ANSI CP1251
/**
*    \brief Заголовочный файл с описанием игры "Крестики-Нолики"
*    \author Admin (Якубовский К.В.)
*    \version 1.1
*    \date 11.09.2022
*    \warning Создано в рамках задач варианта 1.5.1. лабораторной работы 1.1 по учебному предмету ППОИС
*
*    Реализация игры "Крестики-Нолики" на языке С++. Данный файл содержит в себе определение основных классов, функий и т.д.
*/
#pragma once
#ifndef TIC_TAC_TOE_TIC_TAC_H
#define TIC_TAC_TOE_TIC_TAC_H

#include <vector>
#include <iostream>
#include <string>
#include <windows.h>
#include <thread>

/**
*   Функция, выводящая правила игры.
*/
void print_rools();

/**
*   \brief Эмуляция игры в "Крестики-Нолики".
*   \author Admin (Якубовский К.В.).
*   \version 1.0.
*   \date 08.09.2022.
* 
*   \warning Перед началом игры автоматически будут вызваны правила игры.
*   Функция эмулирующая процесс игры двух человек в "Крестики-Нолики".
*   Данную функцию необходимо вызвать для запуска игры.
*   Внутри функции создаётся игровое поле, размер которого вводят игроки.
* 
*   \return Возвращает строку с объявлением победителя или ничьей.
*/
std::string play_tic_tac_toe();

/**
    \brief Основной класс.
    \author Admin (Якубовский К.В.).
    \date 11.09.2022.

    Класс, эмулирующий процесс игры в "Крестики-Нолики".
*/
class tic_tac;

/**
*   \brief Перегрузка оператора вывода в консоль для класса tic_tac.
*   \warning Данный оператор нарушает инкапсуляцию, т.к. имеет доступ к полям и методам класса tic_tac имеющих модификатор доступа private.
*   \param out Ссылка на экземпляр класса std::ostream.
*   \param tt Константная ссылка на экземпляр класса tic_tac, игровое поле которого необходимо вывести в консоль.
*   \return Ссылка на экземпляр класса std::ostream после манипуляций над ним.
*   
*   Выводит игровое поле на консоль.
*/
std::ostream& operator<<(std::ostream& out, const tic_tac& tt);

/**
*   \brief Перегрузка оператора ввода через консоль для класса tic_tac.
*   \warning Данный оператор нарушает инкапсуляцию, т.к. имеет доступ к полям и методам класса tic_tac имеющих модификатор доступа private.
*   \warning Автоматически запускает метод для проверки ввода.
*   \bug При вызове данного метода могут возникать ошибки, описанные в документации к методу check_input. 
*   \param in Ссылка на экземпляр класса std::istream.
*   \param tt Ссылка на экземпляр класса tic_tac, в клетку игрового поля которого необходимо записать знак во время хода игрока.
*   \return Ссылка на экземпляр класса std::istream после манипуляций над ним.
* 
*   Запрашивает у пользователя ввод сначала номера строки, а затем номера столбика клетки, в которую он хочет поставить свой знак.
*/
//Перегруженный оператор ввода номера клетки, в которую пользователь хочет вставить знак
std::istream& operator>>(std::istream& in, tic_tac& tt);

class tic_tac{
private:

    /**
    *   \brief enum состояний клетки.
    *   \author Admin (Якубовский К.В.).
    *   \date 04.09.2022.
    *   \warning Данный enum вложен в класс tic_tac. Модификатор доступа private.
    * 
    *   Вложенный enum с модификатором доступа private, обозначающий состояние клетки: Пусто/Нолик/Крестик. 
    *   Так же данный enum используется для обозначения очерёдности хода.
    */
    enum cell_conditions
    {
        Empty = 0, ///<Указывает, что клетка пуста.
        Noughts = 1, ///<Указывает, что в клетку записан нолик либо ход принадлежит Нолику.
        Crosses = 2, ///<Указываеи, что в клетку записан крестик либо ход принадлежит Крестику.
    };
    
    /**
    *   \brief Вложенный класс cell.
    *   \author Admin (Якубовский К.В.).
    *   \date 06.09.2022.
    *   \warning Данный класс вложен в tic_tac. Модификатор доступа private. Является служебным классом.
    * 
    *   Вложенный служебный класс, являющийся абстрактным представлением клетки на игровом поле. Содержит в себе информацию о состоянии клетки.
    *   Так же в классе содержатся методы, посзовляющие проверить состояние клетки.
    */
    class cell {
    public:

        cell_conditions cell_condition; ///<Состояние клетки (пуста клетка или заполнена крестиком/ноликом).

        /**
        *   Конструктор создания клетки.
        *   \param cond Состояние клетки, которая должна иметь клетка после создания (по умолчанию - Empty: Пустая).
        */
        cell(cell_conditions cond = Empty); 

        /**
        *   Оператор присваивания клетки.
        *   \param other Ссылка на клетку, значения которой необходимо присвоить клетке, для которой вызван оператор.
        *   \return Ссылка на новое значение клетки.
        */
        cell& operator = (const cell& other);

        /**
        *   Конструктор копирования клетки.
        *   \param other Ссылка на клетку, значения которой необходимо копировать в клетку, для которой вызван конструктор.
        */
        cell(const cell& other);

        /**
        *   Проверяет, пуста ли клетка.
        *   \return Результат проверки клетки(true, если клетка пуста).
        */
        bool is_empty();

        /**
        *   Проверяет, пуста ли клетка. Вызывается для константных экземпляров класса cell.
        *   \warning Константный метод.
        *   \return Результат проверки клетки(true, если клетка пуста).
        */
        bool is_empty() const;

        /**
        *   Проверяет, совпадает ли значение клетки с переданным аргументом.
        *   \param cond Значение, с которым необходимо сравнить состояние клетки, для которой вызван метод.
        *   \return Результат проверки клетки(true, если состояние клетки совпадает с cond).
        */
        bool is_condition(cell_conditions cond);

        /**
        *   Проверяет, совпадает ли значение клетки с переданным аргументом. Вызывается для константных экземпляров класса cell.
        *   \warning Константный метод.
        *   \param cond Значение, с которым необходимо сравнить состояние клетки, для которой вызван метод.
        *   \return Результат проверки клетки(true, если состояние клетки совпадает с cond).
        */
        bool is_condition(cell_conditions cond) const; 

    };

    std::vector<std::vector<cell>> field; ///< Абстрактное представление поля для игры в "Крестики-Нолики".

    cell_conditions turn; ///< Абстрактное представление очерёдности хода.

    /**
    *   Изменяет значение поля класса turn, эмулируя передачу хода другому игроку.
    *   \warning Служебный метод. Вызывается в конце хода каждого из игроков.
    */
    void change_turn();

    /**
    *   Возвращает размер игрового поля.
    *   \warning Служебный метод.
    *   \return Возвращает длину стороны игрового поля.
    */
    int size();

    /**
    *   Проверяет на корректность введённые значения номера игровой клетки.
    *   \warning Служебный метод.
    *   \bug Если пользователь будет всегда вводить не целочисленные значения строки или столбца, то он не выйдет из бесконечного цикла.
    *   \bug Вводе целочисленных значений строки и(или) столбца, которые меньше 1 либо больше размера игрового поля может в итоге привести к stack overflow (из-за рекурсивного вызова внутри функции).
    *   \param string_number Ссылка на введённое пользователем значение номера строки игрового поля, которое необходимо проверить.
    *   \param column_number Ссылка на введённое пользователем значение номера строки игрового поля, которое необходимо проверить.
    *   \param fail_counter Счётчик ошибок ввода, допущенных пользователем для оного хода. По достижении определённого значения консоль очищается и поле выводится в консоль заново (По умолчанию равен нулю).
    *   \param index_error Флаг, который сигнализирует о том, что номером строки и(или) стобца является целое число, которое меньше 1 или больше размеров игрового поля.
    */
    void check_input(int& string_number, int& column_number, int fail_counter = 0, bool index_error = false);

    /**
    *   Заполняет клетку, значением ходящего игрока.
    *   \warning Служебный метод.
    *   \param string_number номер строки клетки, в которую будет записан знак.
    *   \param column_number номер столбика клетки, в которую будет записан знак.
    */
    void use_cell(int string_number, int column_number);

    /**
    *   Проверяет наличие победной комбинации.
    *   \warning Служебный метод. Запускается только с size * 2 - 1 ходов, где size - размер игрового поля.
    *   \return Результат проверки (true, если была найдена выигрышная комбинация).
    * 
    *   Данный метод запускаетеся после того, как игрок поставил свой знак в клетку (проверяется комбинация именно для игрока, который только что походил).
    *   Запускается на size * 2 - 1 ходе, т.к. раньше данного хода невозможно получить победную коминацию.
    *   Сам метод запускает 4 проверочных метода в разных потоках и возвращает true, если была найдена победная комбинация.
    */
    bool check_for_win();

    /**
    *   Проверяет наличие победной комбинации по горизонтали.
    *   \warning Служебный метод.
    *   \return Результат проверки (true, если была найдена выигрышная комбинация по горизонатли).
    *   
    *   Проверка выполняется для игрока, который только что походил.
    */
    bool chech_for_horizontal_combination();

    /**
    *   Проверяет наличие победной комбинации по вертикали.
    *   \warning Служебный метод.
    *   \return Результат проверки (true, если была найдена выигрышная комбинация по вертикали).
    *
    *   Проверка выполняется для игрока, который только что походил.
    */
    bool chech_for_vertical_combination();

    /**
    *   Проверяет наличие победной комбинации по главной диагонали (левый верхний угол -> правый нижний угол).
    *   \warning Служебный метод.
    *   \return Результат проверки (true, если была найдена выигрышная комбинация по главной диагонали (левый верхний угол -> правый нижний угол).
    *
    *   Проверка выполняется для игрока, который только что походил.
    */
    bool chech_for_main_diagonal_combination();

    /**
    *   Проверяет наличие победной комбинации по побочной диагонали (правый верхний угол -> левый нижний угол).
    *   \warning Служебный метод.
    *   \return Результат проверки (true, если была найдена выигрышная комбинация по главной диагонали (правый верхний угол -> левый нижний угол).
    *
    *   Проверка выполняется для игрока, который только что походил.
    */
    bool chech_for_secondary_diagonal_combination();

    /**
    *   Возвращает сообщение о выигрыше игрока.
    *   \warning Служебный метод.
    *   \return Строка с сообщением о выйгрыше игрока.
    * 
    *   Метод возвращает строку того игрока, который походил.
    */
    std::string winner_message();

    friend std::ostream& operator<< (std::ostream& out, const tic_tac& tt);

    friend std::istream& operator>>(std::istream& in, tic_tac& tt);

public:

    /**
    *   Конструктор класса tic_tac.
    *   \param size Размер игрового поля (размер одной из сторон поля).
    *   \trow std::exception В случае, если size <= 2, что соответствует некорректному значению размеров игрового поля.  
    * 
    *   Создаёт игровое поле, ячейки которого пусты (cell_condition = Empty).
    *   Так же задаётся значение очерёдности хода. Первый ход за Ноликом, а следовательно очерёдность хода при создании turn = Noughts.
    */
    tic_tac(int size);

    
    /**
    *   Конструктор копирования класса tic_tac.
    *   \param other Ссылка на экзмепляр класса, значения которого необходимо копировать в экземпляр класса, для которой вызван конструктор.
    */
    tic_tac(const tic_tac& other);

    /**
    *   Оператор индексации класса tic_tac.
    *   \param index Индекс, соответсвующий номеру строки клеток игрового поля.
    *   \throw std::exception В случае ошибки при индексации (индекс index < 0 или index > size - 1, где size - размер стороны игрового поля).
    *   \return Ссылкана вектор клеток, которые находились в строке игрового поля под номером index.
    */
    std::vector<cell>& operator[](int index);

    /**
    *   Оператор индексации класса tic_tac. Вызывается для константных экземпляров класса.
    *   \warning Константный метод.
    *   \param index Индекс, соответсвующий номеру строки клеток игрового поля.
    *   \throw std::exception В случае ошибки при индексации (индекс index < 0 или index > size - 1, где size - размер стороны игрового поля).
    *   \return Ссылкана вектор клеток, которые находились в строке игрового поля под номером index.
    */
    std::vector<cell> operator[](int index) const;
    
    /**
    *   Метод эмулирующий игровой процесс.
    *   \warning Ход переходит от одного игрока к другому автоматически.
    *   Первый ход принадлежит Нолику (Noughts).
    *   \return Возвращает строку с сообщением о выигрыше одного из игроков либо о ничьей.
    *   \warning Ничья вызывется только в случае, если все ходы были исчерпаны. Всего ходов size * size, где size - размер стороны игрового поля.
    */
    std::string play();
   
    //Деструктор
    //~tic_tac();

};


#endif //TIC_TAC_TOE_TIC_TAC_H

